---
target: Umo Editor Next
keywords: Umo Editor Next,Umo Editor 官网,富文本编辑器,文档编辑器,文档编辑,协同办公
description: Umo Editor 是一个基于 Vue3 和 Tiptap3 的本土化开源文档编辑器，专为国人用户设计。它提供了强大的文档编辑能力和 AI 创作功能，支持分页模式、Markdown 语法、富文本编辑、多种格式的节点插入、页面样式设置、文档导出与打印等功能。此外，Umo Editor 还支持自定义扩展、多语言设置和暗色主题。
---

import { Callout } from 'nextra/components'

# 基本介绍

<Callout type="warning" emoji="❗" style={{ marginBottom: '50px !important' }}>
  自 V10 开始，Umo Editor Next 完全重构了 AI 的相关功能，相关 API 发生了重大变更，与 V9 版本不兼容。老用户请及时升级。

  V10 版本 AI 的重构，核心目标不是“把功能做得更花”，而是核心思路的转变，是把 AI 从单功能升级为一套面向编辑场景的、可控的能力体系：
  - 前端统一收集编辑器上下文（选区 / 节点级 Markdown / 全文 / 光标标记）、统一流式渲染与写回；
  - 后端作为适配层可对接任意模型，并可在 default / agui 两种协议间选择，做到“可插拔、可扩展、可演进”。
  
  本次重构主要为了解决旧版在工程化落地中常见的痛点：上下文与写回不稳定（不知道该改哪里/改多少）、协议与模型接入割裂（换模型/做工具调用成本高）、前后端职责不清导致安全与维护成本高。
  
  最终带来的收益是：AI 输出更贴近“编辑器内执行”，写回链路更可靠，模型与协议更容易扩展，私有化/合规更容易保障。
</Callout>

---

**Umo Editor Next** 的 AI 能力设计目标是：让 AI 模型在“编辑器内”像一个可靠的 **执行型编辑助手** 工作，帮助用户安全可控、高效快速的完成文档编辑任务，而不是泛聊天机器人。其核心特点是“可控、可复现、可扩展”，并且强依赖编辑器上下文（选区、节点、文档结构、光标位置等）。

AI 接入的核心理念是：

- 前端：负责收集编辑器上下文、发送请求、渲染 SSE 流式内容
- 后端：作为业务侧“适配层 / 代理层”，负责对接任意大模型（包括 OpenAI-compatible 主流模型），并输出符合约定的 SSE 流式内容

## 能力列表

- [AI 文档助手（Assistant）](./assistant)：浮层入口，强调“对选区/光标附近内容进行编辑型输出”，并提供一键替换 / 插入。
- [AI 聊天助手（Chat）](./chat)：侧边栏对话入口，支持历史记录与附件（可选），适合“多轮问答、任务澄清、资料整理”。
- [AI 建议（Suggestion）](./suggestion)：编辑时自动给出候选文本，用 Tab/Enter 直接采纳（偏“自动补全 / 续写”），按上下键切换建议。

## 核心特性

### 流式输出

- 支持 SSE 流式返回：边生成边展示，交互更及时
- 支持非流式返回：一次性返回完整结果（取决于你的后端与模型配置）

### 多协议支持

- 支持默认协议和 AG-UI 标准协议
- AG-UI 标准协议，前端内置解析，更适合 agent 工具调用/多步骤任务/进度状态

### 多模型与推理模式

- 支持配置多个 AI 模型，并在 UI 中切换
- 当模型支持深度思考时，UI 提供“深度思考”开关

### 附件上传

- 支持在 AI 聊天助手中上传图片/文件，并将附件信息随请求发送给后端
- 支持在消息中显示文件和图片

### 多技能模式

内置技能模式用于指导“输出形态”，常见包括：

- `write`：生成/改写 Markdown
- `code`：输出代码块 Markdown
- `katex`：输出公式（KaTeX 友好）
- `mermaid`：输出 Mermaid 图表代码块
- `image`：输出图片相关 Markdown（需你的后端配合）
- `search`：网页解读/总结（更偏理解，不直接改文档）

### 结果可写回

AI 输出完成后，提供完整的“结果处理闭环”：

- 替换：将结果替换当前选区
- 插入：将结果插入到光标位置
- 复制：复制结果到剪贴板
- 重写：重新生成本次结果（regenerate）

### 可插拔的请求生命周期回调

可以在请求生命周期内接入自定义逻辑：

- `onRequest`：统一改写请求（headers/body/路由/鉴权等）
- `onMessage`：在 `default` 协议下，把 SSE chunk 映射成前端可渲染的内容块
- `onStart / onComplete / onAbort / onError`：开始/结束/中止/异常处理

### 隐私与安全（默认更偏“可控”）

- 前端不持有密钥：鉴权与密钥管理由你的后端负责
- 上下文由你掌控：你可以在后端决定“哪些上下文可发送、如何脱敏、是否落日志”
